<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Procedural Earthbending | Carlos Ramos</title>

<meta name="keywords" content="" />
<meta name="description" content="A game that explores the mechanics of VR by implementing a clever algorithm for procedural earhbending.">
<meta name="author" content="jc">
<link rel="canonical" href="http://carlosr.me/projects/earthbending/" />
<link href="http://carlosr.me/assets/css/stylesheet.min.cbc46945de1763cbbfb206e9aec66d73f596c5b76bd39b2808e0b2eb1a2326ce.css" integrity="sha256-y8RpRd4XY8u/sgbprsZtc/WWxbdr05soCOCy6xojJs4=" rel="preload stylesheet"
    as="style">

<link rel="icon" href="http://carlosr.me/site/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="http://carlosr.me/site/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://carlosr.me/site/favicon-32x32.png">
<link rel="apple-touch-icon" href="http://carlosr.me/site/apple-touch-icon.png">
<link rel="mask-icon" href="http://carlosr.me/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<meta name="generator" content="Hugo 0.80.0" />




<link rel="preconnect" href="https://fonts.gstatic.com">
<link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Sans:wght@200;300;400;700&display=swap" rel="stylesheet">
<meta property="og:title" content="Procedural Earthbending" />
<meta property="og:description" content="A game that explores the mechanics of VR by implementing a clever algorithm for procedural earhbending." />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://carlosr.me/projects/earthbending/" />
<meta property="og:image" content="http://carlosr.me/covers/vr.png" /><meta property="article:published_time" content="2020-01-15T00:00:00+00:00" />
<meta property="article:modified_time" content="2020-01-15T00:00:00+00:00" /><meta property="og:see_also" content="http://carlosr.me/projects/spark-rdf/" /><meta property="og:see_also" content="http://carlosr.me/projects/mit-6.824-project/" /><meta property="og:see_also" content="http://carlosr.me/projects/ca-fluid/" /><meta property="og:see_also" content="http://carlosr.me/projects/heatmap-alert/" /><meta property="og:see_also" content="http://carlosr.me/projects/co2-emulator/" />

<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:image" content="http://carlosr.me/covers/vr.png" />
<meta name="twitter:title" content="Procedural Earthbending"/>
<meta name="twitter:description" content="A game that explores the mechanics of VR by implementing a clever algorithm for procedural earhbending."/>

<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Procedural Earthbending",
  "name": "Procedural Earthbending",
  "description": "A game that explores the mechanics of VR by implementing a clever algorithm for procedural earhbending.",
  "keywords": [
    
  ],
  "articleBody": "This project implements the mechanics of Earthbending in VR using Unreal Engine and C++. In the essence the Earthbending is a way to interact with the ground. Our goal is to design an algorithm and figure out controls of earthbending magic. In the most abstract blueprint the task consists of procedural mesh editing and VR technology integration.\nGame style The first idea that came was the game style. It had to be presented in a way that does not require a powerful machine to run complex geometries and fancy effects because we have the limitations of the Oculus Quest device. For this we came with the idea of low poly style. This implied to have meshes with minimum geometry complexity and straightforward texturing. Besides, low poly should allow us to design the level and make changes quicker. Also low poly looks great with proper shading as these examples.\n  Game design The game mechanics played a huge role on the proyect. As initially said, we had the idea of providing the experience of playing with the earthbending effect. We thought that would be great to make it on a VR experience. Then, shaping it into a more game looking experience we designed a game map that compasses the levels, enemies and goals that a proper game should have. This is how the initial game map idea looked like\n  Level concept   This is basically a platform game that requires to the user to climb level by level to reach the highest point and win. Each level is composed by one or many islands in which the enemies are spawned to interrupt and attack the player. Then after getting some great 3d assets from here and here the task was now to build the actual game map. After many hours of level design we got this.\n  Side view (wireframe)     Side view (preview)     Perspective view   Game characters We also needed to get or build actors in the game. For this purpose we got assets to make the game more playable.\nEnemies We have enemies that have the role of blocking the path of the main player character. Each enemy has the same defined behavior: patrol the island, look for the player, attack and die. This is the list of complete enemy actors.\n  Models by @quaternius   Main Game Player The player is the main actor. It is spawned on the first level and hast the goal to reach the highest level. The player has defined interactions that will be described below. Worth to note that we were developing for two types of view player. As First Person Shooter and as VR Person. The first one mainly for developing purposes and the other for the real game interaction. This came with tradeofs to put more effort into one and to take the time to implement more logic into the other. As this is a lesson learned, it will be detailed later.\n  VR Camera Actor   VR integration Oculus Quest was the VR headset of choice because it offers a standalone experience with no extra wires while you are playing. This comes with a cost - a running power. For that extent the natural way to proceed was first to test some applications and some demos testing out the complexity and capacity of the device because in every VR immersion we don’t want to experience lag in the game. The first step was to choose of the right tool for developing the game. The obvious options that comes to one’s mind is between Unity and Unreal Engine. The task was to explore which of them provides less friction in the integration of VR and the game. Both tools provide good documentation and plugins to work with VR right away but we ultimately pick Unreal Engine because of the ease of prototyping cases, the graphics, and the fact that it works with C++. Here is a basic integration in both softwares showing the mapping between the character’s hand and the controls.\nThen, the task was concerned to bring some interaction into the scene. At first, a quick placement of objects with integrated physics was made to be sure they act fluidly once deployed into the headset. It turned out that when the build process started it took quite a long time to get finally into the Quest (like 1hr) because it was required to compile the shaders, build the lights, build the scene, build everything in an android-like package and then it was ready to be tried out. Some time was spent trying to test corner-cases when potentially the physics could break but none were found. Next build and deployment time was faster. Adding more polygons and more complex objects seemed to be ok with this experiment.\nThe next steps were to make the graphics scene of the game, integrate the control buttons to interact with the polygons and area of the floor to have the Earthbending effect. After that the path was to make this more immersive with grain-defined interactions and gameplay. More of the code and blueprints are at the repository.\nGameplay Teleportation Each island can be navigable by the player and the enemy. For doing this, the user has to press and maintain the A button of the VR Control to point into the desired destination and release the button in order to teleport. This was modified to work only on the right hand.\n  Climbing To step up into the next level island the player has to climb the ladder that is located near the edge of the last island. The user has to reach the highest point and realease the grabbing and landing into the next level in which again should have to reach the next ladder. For making this feature possible, a complete understanding of the VR Motion Controller implementation was required (this was also useful later to implement the bending). The climbing was implemented to work on both hands by pressing the backside trigger of the control.\n  Patrolling The enemy is an implemented NPC with basic AI rules. On each level has predefined points what will serve to go from one to another to mimic the behaviour of defending a zone. When the enemy is being distracted or it senses the Player within the defined area, it chases for him.\n  Attacking The player has te ability to attack by bending (defined bellow) and shooting (from FPS view). The enemy attacks by getting close to the player and hitting straight to to the player position. When the player gets far from the enemy, this has the predefined behaviour of following to chase and keeping attack if the player is still within the range.\n  Bending The main player has te ability to attack by bending the terrain of the island in which is currently standing. It makes damage to the enemy when the enemy is in the area of attack.\n  Conclusions We faced many challenges along this journey. We first had to get familiar with the engine and the blueprint terminology. Then the implementation was something that iterated a lot. First with the initial idea of terrain blending by modifying vertex on runtime was not a trivial task. Then we implemented using material behaviour and we got an appealing result. Also implementing for VR was challenging from the first moment. The controlls, the mechanics and optimizations were subjects to be concerned on each stage.\n  Links  Source code  ",
  "wordCount" : "1232",
  "inLanguage": "en",
  "image":"http://carlosr.me/covers/vr.png","datePublished": "2020-01-15T00:00:00Z",
  "dateModified": "2020-01-15T00:00:00Z",
  "author":{
    "@type": "Person",
    "name": "jc"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "http://carlosr.me/projects/earthbending/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Carlos Ramos",
    "logo": {
      "@type": "ImageObject",
      "url": "http://carlosr.me/site/favicon.ico"
    }
  }
}
</script>



</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }
</script>
<noscript>
    <style type="text/css">
        .theme-toggle,
        .top-link {
            display: none;
        }

    </style>
</noscript>
<header class="header">
    <nav class="nav">
        <div class="logo">
            <span class="logo-switches">
            </span>
        </div>
        <ul class="menu" id="menu" onscroll="menu_on_scroll()">
              <li>
                  <a href="http://carlosr.me/" title="Home">
                      <span>Home</span>
                  </a>
              </li>
              <li>
                  <a href="http://carlosr.me/series/blog" title="Blog">
                      <span>Blog</span>
                  </a>
              </li>
              <li>
                  <a href="http://carlosr.me/series/projects" title="Projects">
                      <span>Projects</span>
                  </a>
              </li>
              <li>
                  <a href="http://carlosr.me/about" title="About">
                      <span>About</span>
                  </a>
              </li>
            <li class="theme-toggle" title="(Alt + T)">
              <a id="theme-toggle" accesskey="t">
              <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor"
                stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-toggle-left">
                <rect x="1" y="5" width="22" height="14" rx="7" ry="7"></rect>
                <circle cx="8" cy="12" r="3"></circle>
              </svg>
              <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor"
                stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-toggle-right">
                <rect x="1" y="5" width="22" height="14" rx="7" ry="7"></rect>
                <circle cx="16" cy="12" r="3"></circle>
              </svg>
              </a>
            </li>
        </ul>
    </nav>
</header>

    <main class="main">

<article class="post-single">
  <header class="post-header">
    <h1 class="post-title">
      Procedural Earthbending
    </h1>
    <div class="post-meta">Jan 15, 2020

    </div>
  </header>
  
  <div class="toc">
    <details >
      <summary accesskey="c" title="(Alt + C)">
        <div class="details">Table of Contents</div>
      </summary>
      <blockquote><ul><li>
        <a href="#game-style" aria-label="Game style">Game style</a></li><li>
        <a href="#game-design" aria-label="Game design">Game design</a></li><li>
        <a href="#game-characters" aria-label="Game characters">Game characters</a><ul>
            <li>
        <a href="#enemies" aria-label="Enemies">Enemies</a></li><li>
        <a href="#main-game-player" aria-label="Main Game Player">Main Game Player</a></li><li>
        <a href="#vr-integration" aria-label="VR integration">VR integration</a></li></ul>
    </li><li>
        <a href="#gameplay" aria-label="Gameplay">Gameplay</a></li><li>
        <a href="#teleportation" aria-label="Teleportation">Teleportation</a></li><li>
        <a href="#climbing" aria-label="Climbing">Climbing</a></li><li>
        <a href="#patrolling" aria-label="Patrolling">Patrolling</a></li><li>
        <a href="#attacking" aria-label="Attacking">Attacking</a></li><li>
        <a href="#bending" aria-label="Bending">Bending</a></li><li>
        <a href="#conclusions" aria-label="Conclusions">Conclusions</a></li><li>
        <a href="#links" aria-label="Links">Links</a></li></ul>
      </blockquote>
    </details>
  </div>
  <div class="post-content">
<p>This project implements the mechanics of Earthbending in VR using Unreal Engine and C++. In the essence the Earthbending is a way to interact with the ground. Our goal is to design an algorithm and figure out controls of earthbending magic. In the most abstract blueprint the task consists of procedural mesh editing and VR technology integration.</p>
<h2 id="game-style">Game style<a hidden class="anchor" aria-hidden="true" href="#game-style">#</a></h2>
<p>The first idea that came was the game style. It had to be presented in a way that does not require a powerful machine to run complex geometries and fancy effects because we have the limitations of the Oculus Quest device. For this we came with the idea of low poly style. This implied to have meshes with minimum geometry complexity and straightforward texturing. Besides, low poly should allow us to design the level and make changes quicker. Also low poly looks great with proper shading as these examples.</p>
<figure>
    <img src="images/5970-big.jpg#center" width="90%"/> 
</figure>

<h2 id="game-design">Game design<a hidden class="anchor" aria-hidden="true" href="#game-design">#</a></h2>
<p>The game mechanics played a huge role on the proyect. As initially said, we had the idea of providing the experience of playing with the earthbending effect. We thought that would be great to make it on a VR experience. Then, shaping it into a more game looking experience we designed a game map that compasses the levels, enemies and goals that a proper game should have. This is how the initial game map idea looked like</p>
<figure>
    <img src="images/1.png#center" width="90%"/> <figcaption>
            Level concept
        </figcaption>
</figure>

<p>This is basically a platform game that requires to the user to climb level by level to reach the highest point and win. Each level is composed by one or many islands in which the enemies are spawned to interrupt and attack the player. Then after getting some great 3d assets from here and here the task was now to build the actual game map. After many hours of level design we got this.</p>
<p><figure>
    <img src="images/final-side.png#center" width="90%"/> <figcaption>
            Side view (wireframe)
        </figcaption>
</figure>

<figure>
    <img src="images/final-side-b.png#center" width="90%"/> <figcaption>
            Side view (preview)
        </figcaption>
</figure>

<figure>
    <img src="images/final-perspective.png#center" width="90%"/> <figcaption>
            Perspective view
        </figcaption>
</figure>
</p>
<h2 id="game-characters">Game characters<a hidden class="anchor" aria-hidden="true" href="#game-characters">#</a></h2>
<p>We also needed to get or build actors in the game. For this purpose we got assets to make the game more playable.</p>
<h3 id="enemies">Enemies<a hidden class="anchor" aria-hidden="true" href="#enemies">#</a></h3>
<p>We have enemies that have the role of blocking the path of the main player character. Each enemy has the same defined behavior: patrol the island, look for the player, attack and die. This is the list of complete enemy actors.</p>
<figure>
    <img src="images/Preview.png#center" width="70%"/> <figcaption>
            Models by @quaternius
        </figcaption>
</figure>

<h3 id="main-game-player">Main Game Player<a hidden class="anchor" aria-hidden="true" href="#main-game-player">#</a></h3>
<p>The player is the main actor. It is spawned on the first level and hast the goal to reach the highest level. The player has defined interactions that will be described below. Worth to note that we were developing for two types of view player. As First Person Shooter and as VR Person. The first one mainly for developing purposes and the other for the real game interaction. This came with tradeofs to put more effort into one and to take the time to implement more logic into the other. As this is a lesson learned, it will be detailed later.</p>
<figure>
    <img src="images/vrplayer.png#center" width="100%"/> <figcaption>
            VR Camera Actor
        </figcaption>
</figure>

<h3 id="vr-integration">VR integration<a hidden class="anchor" aria-hidden="true" href="#vr-integration">#</a></h3>
<p>Oculus Quest was the VR headset of choice because it offers a standalone experience with no extra wires while you are playing. This comes with a cost - a running power. For that extent the natural way to proceed was first to test some applications and some demos testing out the complexity and capacity of the device because in every VR immersion we don&rsquo;t want to experience lag in the game. The first step was to choose of the right tool for developing the game. The obvious options that comes to one&rsquo;s mind is between Unity and Unreal Engine. The task was to explore which of them provides less friction in the integration of VR and the game. Both tools provide good documentation and plugins to work with VR right away but we ultimately pick Unreal Engine because of the ease of prototyping cases, the graphics, and the fact that it works with C++. Here is a basic integration in both softwares showing the mapping between the character&rsquo;s hand and the controls.</p>
<p>Then, the task was concerned to bring some interaction into the scene. At first, a quick placement of objects with integrated physics was made to be sure they act fluidly once deployed into the headset. It turned out that when the build process started it took quite a long time to get finally into the Quest (like 1hr) because it was required to compile the shaders, build the lights, build the scene, build everything in an android-like package and then it was ready to be tried out. Some time was spent trying to test corner-cases when potentially the physics could break but none were found. Next build and deployment time was faster. Adding more polygons and more complex objects seemed to be ok with this experiment.</p>
<p>The next steps were to make the graphics scene of the game, integrate the control buttons to interact with the polygons and area of the floor to have the Earthbending effect. After that the path was to make this more immersive with grain-defined interactions and gameplay. More of the code and blueprints are at the repository.</p>
<h2 id="gameplay">Gameplay<a hidden class="anchor" aria-hidden="true" href="#gameplay">#</a></h2>
<h2 id="teleportation">Teleportation<a hidden class="anchor" aria-hidden="true" href="#teleportation">#</a></h2>
<p>Each island can be navigable by the player and the enemy. For doing this, the user has to press and maintain the A button of the VR Control to point into the desired destination and release the button in order to teleport. This was modified to work only on the right hand.</p>
<figure>
    <img src="images/teleport.gif#center" width="60%"/> 
</figure>

<h2 id="climbing">Climbing<a hidden class="anchor" aria-hidden="true" href="#climbing">#</a></h2>
<p>To step up into the next level island the player has to climb the ladder that is located near the edge of the last island. The user has to reach the highest point and realease the grabbing and landing into the next level in which again should have to reach the next ladder. For making this feature possible, a complete understanding of the VR Motion Controller implementation was required (this was also useful later to implement the bending). The climbing was implemented to work on both hands by pressing the backside trigger of the control.</p>
<figure>
    <img src="images/climbing.gif#center" width="60%"/> 
</figure>

<h2 id="patrolling">Patrolling<a hidden class="anchor" aria-hidden="true" href="#patrolling">#</a></h2>
<p>The enemy is an implemented NPC with basic AI rules. On each level has predefined points what will serve to go from one to another to mimic the behaviour of defending a zone. When the enemy is being distracted or it senses the Player within the defined area, it chases for him.</p>
<figure>
    <img src="images/patrolling.gif#center" width="60%"/> 
</figure>

<h2 id="attacking">Attacking<a hidden class="anchor" aria-hidden="true" href="#attacking">#</a></h2>
<p>The player has te ability to attack by bending (defined bellow) and shooting (from FPS view). The enemy attacks by getting close to the player and hitting straight to to the player position. When the player gets far from the enemy, this has the predefined behaviour of following to chase and keeping attack if the player is still within the range.</p>
<figure>
    <img src="images/attacking.gif#center" width="60%"/> 
</figure>

<h2 id="bending">Bending<a hidden class="anchor" aria-hidden="true" href="#bending">#</a></h2>
<p>The main player has te ability to attack by bending the terrain of the island in which is currently standing. It makes damage to the enemy when the enemy is in the area of attack.</p>
<figure>
    <img src="images/bending2.gif#center" width="60%"/> 
</figure>

<h2 id="conclusions">Conclusions<a hidden class="anchor" aria-hidden="true" href="#conclusions">#</a></h2>
<p>We faced many challenges along this journey. We first had to get familiar with the engine and the blueprint terminology. Then the implementation was something that iterated a lot. First with the initial idea of terrain blending by modifying vertex on runtime was not a trivial task. Then we implemented using material behaviour and we got an appealing result. Also implementing for VR was challenging from the first moment. The controlls, the mechanics and optimizations were subjects to be concerned on each stage.</p>

<div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
  <iframe src="https://www.youtube.com/embed/bQVc1d_HTHo" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" allowfullscreen title="YouTube Video"></iframe>
</div>

<h2 id="links">Links<a hidden class="anchor" aria-hidden="true" href="#links">#</a></h2>
<ul>
<li><a href="https://github.com/michaelnitsenko/earthbending">Source code</a></li>
</ul>

</div>
  <footer class="post-footer">
    
  </footer>
</article>
    </main><footer class="footer">
    <span>&copy; 2021 <a href="http://carlosr.me/">Carlos Ramos</a></span>
    
    
    <span>&middot;</span>
    <span><a href="https://github.com/0x7b1" rel="noopener" target="_blank">Licenses</a></span>
</footer>
<a href="#top">
    <button class="top-link" id="top-link" type="button" aria-label="go to top" title="Go to Top (Alt + G)"
        accesskey="g">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6">
            <path d="M12 6H0l6-6z" />
        </svg>
    </button>
</a>



<script>
    window.onload = function () {
        if (localStorage.getItem("menu-scroll-position")) {
            document.getElementById('menu').scrollLeft = localStorage.getItem("menu-scroll-position");
        }
    }
    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                behavior: "smooth"
            });
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.replaceState(null, null, `#${id}`);
            }
        });
    });
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

    function menu_on_scroll() {
        localStorage.setItem("menu-scroll-position", document.getElementById('menu').scrollLeft);
    }

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>

</body>

</html>
